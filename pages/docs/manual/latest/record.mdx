# Record

Records are like JavaScript objects but are:

- lighter
- immutable by default
- fixed in field names and types
- a bit more rigidly typed

## Usage

A record needs a mandatory type declaration:

```re
type person = {
  age: int,
  name: string
};
```

Value (this will be inferred to be of type `person`, declared above):

```re
let me = {
  age: 5,
  name: "Big ReScript"
}
```

Access (the familiar dot notation):

```re
let name = me.name
```

### Record Needs an Explicit Definition

If you only write `{age: 5, name: "Baby ReScript"}` without an explicit declaration somewhere above, the type system will give you an error. If the type definition resides in another file, you need to explicitly indicate which file it is:

```re
// School.res

type person = {age: int, name: string}
```

```re
// Example.res

let me: School.person = {age: 20, name: "Big ReScript"}
/* or */
let me = School.{age: 20, name: "Big ReScript"}
/* or */
let me = {School.age: 20, name: "Big ReScript"}
```

Either of the above 3 says "this record's definition is found in the School file". The first one, the regular type annotation, is preferred.

### Immutable Update

New records can be created from old records with the `...` spread operator. The original record isn't mutated.

```re
let meNextYear = {...me, age: me.age + 1}
```

This update is very efficient! Try a few in our [playground](//reasonml.github.io/try.html) to see how records are compiled.

**Note**: spread cannot add new fields, as a record's shape is fixed by its type.

### Mutable Update

Record fields can optionally be mutable. This allows you to update those fields in-place with the `=` operator.

```re
type person = {
  name: string,
  mutable age: int
}
let baby = {name: "Baby ReScript", age: 5}
baby.age = baby.age + 1 /* alter `baby`. Happy birthday! */
```

## Tips & Tricks

### Record Types Are Found By Field Name

With records, you **cannot** say "I'd like this function to take any record type, as long as they have the field `age`". The following _works_, but not as expected:

```re
type person = {age: int, name: string}
type monster = {age: int, hasTentacles: bool}

let getAge = (entity) => entity.age
```

The last line's function will infer that the parameter `entity` must be of type `monster`. The following code's last line fails:

```re
let kraken = {age: 9999, hasTentacles: true}
let me = {age: 5, name: "Baby ReScript"}

getAge(kraken)
getAge(me)
```

The type system will complain that `me` is a `person`, and that `getAge` only works on `monster`. If you need such capability, use Reason objects, described [here](object.md).

## Design Decisions

After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.

1. The truth is that most of the times in your app, your data's shape is actually fixed, and if it's not, it can potentially be better represented as a combination of variant (introduced next) + record instead.
3. Finally, since a record type is resolved through finding that single explicit type declaration (we call this "nominal typing"), the type error messages end up better than the counterpart ("structural typing", like for tuples). This makes refactoring easier; changing a record type's fields naturally allows the compiler to know that it's still the same record, just misused in some places. Otherwise, under structural typing, it might get hard to tell whether the definition site or the usage site is wrong.
