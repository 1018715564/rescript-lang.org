# Imperative Loops

## For Loops

For loops iterate from a starting value up to (and including) the ending value.

```re
for myBinding in startValue to endValue {
  // use myBinding here
}
```

The parenthesis around `startValue` and `endValue` may be omitted if they are
unnecessary.

```re
let xStart = 1
let xEnd = 3

// prints: 1 2 3
for (x in xStart to xEnd) {
  Js.log(x)
  Js.log(" ")
}
```

You can make the `for` loop count in the opposite direction by using `downto`.

```re
for myBinding in startValue downto endValue {
  statements
}
```

```re
let xStart = 3
let xEnd = 1

// prints: 3 2 1
for x in xStart downto xEnd {
  Js.log(x)
  Js.log(" ")
}
```

## While Loops

While loops execute a code block while some condition is true. The form of a `while` loop includes a single expression, the condition to test.

```re
while testCondition {
  statements
}
```

## Tips & Tricks

There's no loop-breaking `break` keyword (nor early `return` from functions, for that matter) in ReScript. However, we can break out of a while loop easily through using a [mutable binding](mutation.mdx).

```re
Random.self_init()

let break = ref(false)

while (!break.contents) {
  if (Random.int(10) === 3) {
    break := true
  } else {
    Js.log("hello")
  }
}
```

### Recursive functions

Another technique to accomplish an early `return` is by using recursive functions. If we look at our example from the [Recursive functions section](function.mdx#recursive-functions):

```re
let rec listHas = (list, item) =>
  switch list {
  | list{} => false
  | list{a, ...rest} => a == item || listHas(rest, item)
  }
```

The `listHas` function will return `true` as soon as `a == item` is `true`. Otherwise, it calls itself again and continues the search.

We don't have a preference on whether you should use a loop over `map`/`filter`. Some algorithms are better expressed with the former, and some with the latter. Avoid `reduce` as much as possible though. It's usually harder to read and much less performant than just a simple loop.
