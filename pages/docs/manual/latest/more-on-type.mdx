# More on Type

## Type Argument

Types can accept parameters, akin to generics in other languages. It's as if a type is a function that takes in arguments and returns a new type! The parameters **need** to start with `'`.

The use-case of a parameterized type is to kill duplications. Before:

```res
// this is a tuple of 3 items, explained next
type intCoordinates = (int, int, int)
type floatCoordinates = (float, float, float)

let buddy: intCoordinates = (10, 20, 20)
```

After:

```res
type coordinates<'a> = ('a, 'a, 'a)

// apply the coordinates "type function" and return the type (int, int, int)
type intCoordinatesAlias = coordinates<int>

let buddy: intCoordinatesAlias = (10, 20, 20)

// or, more commonly, write it inline
let buddy: coordinates<float> = (10.5, 20.5, 20.5)
```

In practice, types are inferred for you. So the more concise version of the above example would be nothing but:

```res
let buddy = (10, 20, 20)
```

The type system infers that it's a `(int, int, int)`. Nothing else needed to be written down.

Type arguments appear everywhere.

```res
// inferred as `array<string>`
let greetings = ["hello", "world", "how are you"]
```

If types didn't accept parameters (ie, if we didn't have "type functions"), the standard library would need to define the types `arrayOfString`, `arrayOfInt`, `arrayOfTuplesOfInt`, etc.

Types can receive more arguments, and be composable.

```res
type result<'a, 'b> =
  | Ok('a)
  | Error('b)

type myPayload = {data: string}

type myPayloadResults<'errorType> = array<result<myPayload, 'errorType>>

let payloadResults: myPayloadResults(string) = [
  Ok({data: "hi"}),
  Ok({data: "bye"}),
  Error("Something wrong happened!")
]
```

## Recursive Types

Just like a functions, a type can reference itself within itself `rec`:

```res
type rec person = {
  name: string,
  friends: array<person>
}
```

## Mutually Recursive Types

Types can also be _mutually_ recursive through `and`:

```res
type student = {taughtBy: teacher}
and teacher = {students: array<student>}
```

## Type Escape Hatch

ReScript's type system is robust and does not allow dangerous, unsafe stuff like implicit type casting, randomly guessing a value's type, etc. However, out of pragmatism, we expose a single escape hatch for you to "lie" to the type system:

```res
external myShadyConversion : myType1 => myType2 = "%identity"
```

This declaration converts a `myType1` of your choice to `myType2` of your choice. You can use it like so:

```res
external convertToFloat : int => float = "%identity"
let age = 10
let gpa = 2.1 +. convertToFloat(age)
```

Obviously, do **not** abuse this feature. Use it tastefully when you're working with existing, overly dynamic JS code, for example.

More on externals [here](external.md).

**Note**: this particular `external` is the only one that isn't preceded by a `@bs` annotation.
