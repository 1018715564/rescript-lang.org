# String and Char

## String

ReScript strings are delimited using **double** quotes (single quotes are reserved for the character type below).

```re
let greeting = "Hello world!"
let multilineGreeting = "Hello
 world!"
```

Special characters in the string need to be escaped:

```re
let oneSlash = "\\"
```

To concatenate strings, use `++`:

```re
let greetings = "Hello " ++ "world!"
```

### String Interpolation

There's a special syntax for string that allows

- multiline string just like before
- no special character escaping
- Interpolation
- Proper unicode handling

```re
let greetingAndOneSlash = `Hello
World
\
Hehe...
`
```

This is just like JavaScript's backtick string interpolation, except without needing to escape special characters.

### Usage

[More string operations can be found in the standard library](https://reasonml.github.io/api/String.html). For JS compilation, see the familiar `Js.String` API in the [BuckleScript API docs](/apis/javascript/latest/js/string). Since a ReScript string maps to a JavaScript string, you can mix & match the string operations in both standard libraries.

### Tips & Tricks

**You have a good type system now**! In an untyped language, you'd often overload the meaning of string by using it as:

- a unique id: `var BLUE_COLOR = "blue"`
- an identifier into a data structure: `var BLUE = "blue" var RED = "red" var colors = [BLUE, RED]`
- the name of an object field: `person["age"] = 24`
- an enum: `if (audio.canPlayType() === 'probably') {...}` [(ಠ_ಠ)](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value)
- other crazy patterns you'll soon find horrible, after getting used to ReScript's alternatives.

The more you overload the poor string type, the less the type system (or a teammate) can help you! ReScript provides concise, fast and maintainable types & data structures alternatives to the use-cases above (e.g. variants, in a later section).

Under native compilation, ReScript strings compile to a simple representation whose performance is straightforward to analyze, at the expense of sometimes requiring manual performance tuning. For example, naively concatenating strings like `"hi " ++ "how " ++ "are " ++ "you?"` unnecessarily allocates the intermediate strings `"are you?"` and `"how are you?"` (though it might be optimized into a single string in these simple cases). In this case, prefer [`String.concat`](//reasonml.github.io/api/String.html). In a way, it's somewhat nice that the traditional runtime analysis we've learned in school can finally be useful again.

Under JavaScript compilation, a ReScript string maps to a JavaScript string and vice-versa, so no such above concern or analysis opportunities apply.

## Char

ReScript has a type for a string with a single letter:

```re
let firstLetterOfAlphabet = 'a'
```

**Note**: Char doesn't support Unicode or UTF-8 and is therefore disrecommended.

To convert a String to a Char, use `"a".[0]`. To convert a Char to a String, use `String.make(1, 'a')`.
