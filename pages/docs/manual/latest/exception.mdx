# Exception

Exceptions are just a special kind of variant, "thrown" in **exceptional** cases (don't abuse them!).

## Usage

```re
let getItem = (theList) =>
  if callSomeFunctionThatThrows() {
    // return the found item here
  } else {
    raise(Not_found)
  }

let result =
  try {
    getItem([1, 2, 3])
  } catch {
  | Not_found => 0 // Default value if getItem throws
  }
```

Note that the above is just for demonstration purposes; in reality, you'd return an `option(int)` directly from `getItem` and avoid the `try` altogether.

You can directly match on exceptions _while_ getting another return value from a function:

```re
switch List.find((i => i === theItem, myItems)) {
| item => Js.log(item)
| exception Not_found => Js.log("No such item found!")
}
```

You can also make your own exceptions like you'd make a variant (exceptions need to be capitalized too).

```re
exception InputClosed(string)
// later on
raise(InputClosed("the stream has closed!"))
```

## Tips & Tricks

When you have ordinary variants, you often don't **need** exceptions. For example, instead of throwing when `item` can't be found in a collection, try to return an `option<item>` (`None` in this case) instead.
