# Lazy Values

A lazy value represents a deferred computation which will automatically memoize the result on the first run, and then return the memoized result on any repeated execution.

This is useful for defining functions and expressions for complex procedures that always return the same value, for example:

- Doing expensive DOM traversals over the same tree over and over again
- Doing file system operations on a static set of files that won't change 
- Doing expensive requests to an API server that would always return the same data

A lazy value has a type of `Lazy.t('a)`, where `'a` is the return value of the computation. All its functionality is encapsulated with the globally available `Lazy` module.

## Creating a lazy value

Lazy values are part of the language. You can either use the `lazy` keyword to create a lazy value from an expression...

```re example
// We only want getFiles to read the file system once,
// so we wrap it in a lazy value
let getFiles =
  lazy({
    Js.log("Reading dir");
    Node.Fs.readdirSync("./pages");
  });

// On the first call, the computation takes place
Lazy.force(getFiles)->Js.log;

// The second call will just return the already calculated files
Lazy.force(getFiles)->Js.log;
```

... or you can also wrap an existing function to make it lazy:

```reason example
let getFiles = () => { Node.Fs.readdirSync("./pages"); };

// Note: getFiles() is not actually called within the lazy expression!
let lazyGetFiles = Lazy.from_fun(getFiles);
```

Note that `getFiles()` inside the `lazy` expression is not evaluated right away (its type will be `Lazy.t(array(string))`! This is because `lazy(...)` is not a function and will be treated differently by the compiler.

Alternatively we can use `Lazy.from_fun(getFiles)` to create the same lazy value.


## Force a lazy computation

Lazy values need to be explicitly executed to be able to return a value. Use the `Lazy.force`to start the execution:

```re example
let computation = lazy(1);

// Returns 1
Lazy.force(computation);
```

It is also possible to use pattern matching to force a lazy value to compute, this includes `switch` expressions and similar syntax such as tuple destructing:

```re example
// Pattern matching syntax
let computation = lazy("computed"); 

switch(computation) {
 | lazy("computed") => Js.log("ok")
 | _ => Js.log("not ok")
};

// Tuple Destructing
let lazyValues = (lazy("hello"), lazy("world"));
let (lazy(word1), lazy(word2)) = lazyValues;

// Logs "hello world"
Js.log2(word1, word2);
```

As you can see, the `lazy` syntax is a really great way for creating and handling lazy computations!

## Exception handling

Whenever a lazy value computation raises an exception, the same exception will be thrown by `Lazy.force`.

```re example
exception NoFile;

let readFile =
  lazy(
    {
      raise(NoFile);
    }
  );

try(Lazy.force(readFile)) {
  | NoFile => Js.log("No file")
};
```

Nothing new here, since we are using the `try` expression to match the exception raised in the lazy computation context!

Please remember: Exceptions should be used sparsely!


## Runtime Representation

A lazy value is a wrapped data structure with different shapes depending on the status of the computation.

If the lazy value hasn't been forced to compute, the value is represented as a JS array with a function and an attached magic `tag` attribute (`[ [Function], tag: 246]`).

If the value **has been forced**, the runtime representation will be the actual result of the computation.

(Please note that the magic tag attribute doesn't yield any practical value and should be ignored)

**Example:**

```re
let value = lazy(string_of_int(1));

// Outputs: [ [Function], tag: 246 ]
Js.log(value);

// Outputs: 1
Lazy.force(value)->Js.log;
```

The runtime representation will change in the upcoming `v8` release (see this [blog post](/blog/a-story-of-lazy-encoding) for more infos).



