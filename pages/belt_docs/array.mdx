import {make as Layout} from "../../layouts/MainLayout.bs.js"
export default Layout

---
id: array
title: Array
---

Utililites for Array functions.

## length

```
let length: array('a) => int;
```

return the size of the array

## size

```
let size: array('a) => int;
```

See Belt_Array.length

## get

```
let get: (array('a), int) => option('a);
```

If `i <= 0 <= length(arr)` returns `Some(value)` where `value` is the item at index `i`.
If `i` is out of range returns `None`

## getExn

```
let getExn: (array('a), int) => 'a;
```

Raise an exception if `i` is out of range.
Otherwise return the value at index `i` in `arr`.

## getUnsafe

```
let getUnsafe: (array('a), int) => 'a;
```

Unsafe

no bounds checking; this would cause type error if `i` does not stay within range

## getUndefined

```
let getUndefined: (array('a), int) => Js.undefined('a);
```

It does the samething in the runtime as `Belt_Array.getUnsafe` it is type safe since the return type still track whether it is in range or not

## set

```
let set: (array('a), int, 'a) => bool;
```

`set(arr, n, x);` modifies `arr` in place; it replaces the nth element of `arr` with `x`.

Returns false means not updated due to out of range.

## setExn

```
let setExn: (array('a), int, 'a) => unit;
```

`setExn(arr, i, x);` raise an exception if `i` is out of range.

## setUnsafe

```
let setUnsafe: (array('a), int, 'a) => unit;
```

## shuffleInPlace

```
let shuffleInPlace: array('a) => unit;
```

`shuffleInPlace(arr)` randomly re-orders the items in `arr`

## shuffle

```
let shuffle: array('a) => array('a);
```

Returns a fresh array with items in original array randomly shuffled.

## reverseInPlace

```
let reverseInPlace: array('a) => unit;
```

`reverseInPlace(arr)` reverses items in `arr` in place.

Examples

```
let arr = [|10, 11, 12, 13, 14|];

let () = reverseInPlace(arr);

arr == [|14, 13, 12, 11, 10|];
```

## reverse

```
let reverse: array('a) => array('a);
```

`reverse(arr)` returns a fresh array with items in arr in reverse order.

Examples

```
reverse([|10, 11, 12, 13, 14|]) == [|14, 13, 12, 11, 10|];
```

## makeUninitialized

```
let makeUninitialized: int => array(Js.undefined('a));
```

`makeUninitialized(n)` creates an array of length `n` filled with the undefined value. You must specify the type of data that will eventually fill the array.

Examples

```
let arr: array(Js.undefined(string)) = makeUninitialized(5);

getExn(arr, 0) == Js.undefined;
```

## makeUninitializedUnsafe

```
let makeUninitializedUnsafe: int => array('a);
```

Unsafe

Examples

```
let arr = Belt.Array.makeUninitializedUnsafe(5);

let () = Js.log(Belt.Array.getExn(arr, 0)); /* undefined */

Belt.Array.setExn(arr, 0, "example");

let () = Js.log(Belt.Array.getExn(arr, 0) == "example");
```

## make

```
let make: (int, 'a) => array('a);
```

`make(n, e)` return an array of size `n` filled with value `e`.
Returns an empty array when `n` is negative.

## range

```
let range: (int, int) => array(int);
```

`range(start, finish);` create an inclusive array.

Examples

```
range(0, 3) == [|0, 1, 2, 3|];

range(3, 0) == [||];

range(3, 3) == [|3|];
```

## rangeBy

```
let rangeBy: (int, int, ~step: int) => array(int);
```

`rangeBy(start, finish, ~step);`

Returns empty array when step is 0 or negative. It also return an empty array when `start > finish`.

Examples

```
rangeBy(0, 10, ~step=3) == [|0, 3, 6, 9|];

rangeBy(0, 12, ~step=3) == [|0, 3, 6, 9, 12|];

rangeBy(33, 0, ~step=1) == [||];

rangeBy(33, 0, ~step=-1) == [||];

rangeBy(3, 12, ~step=-1) == [||];

rangeBy(3, 3, ~step=0) == [||];

rangeBy(3, 3, ~step=1) == [|3|];
```

## makeByU

```
let makeByU: (int, [@bs] (int => 'a)) => array('a);
```

## makeBy

```
let makeBy: (int, int => 'a) => array('a);
```

`makeBy(n, f);`

Return an empty array when n is negative return an array of size n populated by `f(i)` start from `0` to `n - 1`.

Examples

```
makeBy(5, (i) => i) == [|0, 1, 2, 3, 4|];

makeBy(5, (i) => i * i) == [|0, 1, 4, 9, 16|];
```

## makeByAndShuffleU

```
let makeByAndShuffleU: (int, [@bs] (int => 'a)) => array('a);
```

## makeByAndShuffle

```
let makeByAndShuffle: (int, int => 'a) => array('a);
```

`makeByAndShuffle(n, f);`

Equivalent to `shuffle(makeBy(n, f));`

## zip

```
let zip: (array('a), array('b)) => array(('a, 'b));
```

`zip(a, b);`

Create an array of pairs from corresponding elements of a and b. Stop with the shorter array.

Examples:

```
Belt.Array.zip([|1, 2|], [|3, 4, 5|]) == [|(1, 3), (2, 4)|]
```

## zipByU

```
let zipByU: (array('a), array('b), [@bs] (('a, 'b) => 'c)) => array('c);
```

## zipBy

```
let zipBy: (array('a), array('b), ('a, 'b) => 'c) => array('c);
```

`zipBy(xs, ys, f);`

Create an array by applying `f` to corresponding elements of `xs` and `ys`. Stops with shorter array.

Equivalent to `map(zip(xs, ys), ((a, b)) => f(a, b));`

Examples

```
zipBy([|1, 2, 3|], [|4, 5|], (a, b) => 2 * a + b) == [|6, 9|];
```

## unzip

```
let unzip: array(('a, 'b)) => (array('a), array('b));
```

`unzip(a);` takes an array of pairs and creates a pair of arrays. The first array contains all the first items of the pairs; the second array contains all the second items.

Examples

```
unzip([|(1, 2), (3, 4)|]) == ([|1, 3|], [|2, 4|]);

unzip([|(1, 2), (3, 4), (5, 6), (7, 8)|]) == ([|1, 3, 5, 7|], [|2, 4, 6, 8|]);
```

## concat

```
let concat: (array('a), array('a)) => array('a);
```

`concat(xs, ys);`

Returns a fresh array containing the concatenation of the arrays `v1` and `v2`;so even if `v1` or `v2` is empty; it can not be shared

Examples

```
concat([|1, 2, 3|], [|4, 5|]) == [|1, 2, 3, 4, 5|];

concat([||], [|"a", "b", "c"|]) == [|"a", "b", "c"|];
```

## concatMany

```
let concatMany: array(array('a)) => array('a);
```

`concatMany(xss);`

Returns a fresh array as the concatenation of `xss` (an array of arrays)

Examples

```
concatMany([|[|1, 2, 3|], [|4, 5, 6|], [|7, 8|]|]) == [|1, 2, 3, 4, 5, 6, 7, 8|];
```

## slice

```
let slice: (array('a), ~offset: int, ~len: int) => array('a);
```

`slice(xs, offset, len);` creates a new array with the len elements of `xs` starting at `offset` for

`offset` can be negative;and is evaluated as `length(xs) - offset(slice, xs) - 1(1);` means get the last element as a singleton array

`slice(xs, ~-len, len);` will return a copy of the array

if the array does not have enough data; `slice` extracts through the end of sequence.

if `len` is negative; returns the empty array.

Examples

```
slice([|10, 11, 12, 13, 14, 15, 16|], ~offset=2, ~len=3) == [|12, 13, 14|];

slice([|10, 11, 12, 13, 14, 15, 16|], ~offset=-4, ~len=3) == [|13, 14, 15|];

slice([|10, 11, 12, 13, 14, 15, 16|], ~offset=4, ~len=9) == [|14, 15, 16|];
```

## sliceToEnd

```
let sliceToEnd: (array('a), int) => array('a);
```

`sliceToEnd(xs, offset);` creates a new array with the elements of `xs` starting at `offset`

`offset` can be negative; and is evaluated as `length(xs) - offset(sliceToEnd, xs) - 1;` means get the last element as a singleton array

`sliceToEnd(xs, 0);` will return a copy of the array

Examples

```
sliceToEnd([|10, 11, 12, 13, 14, 15, 16|], 2) == [|12, 13, 14, 15, 16|];

sliceToEnd([|10, 11, 12, 13, 14, 15, 16|], -4) == [|13, 14, 15, 16|];
```

## copy

```
let copy: array('a) => array('a);
```

`copy(a);`

Returns a copy of a; that is; a fresh array containing the same elements as a.

## fill

```
let fill: (array('a), ~offset: int, ~len: int, 'a) => unit;
```

`fill(arr, ~offset, ~len, x);`

Modifies `arr` in place, storing `x` in elements number `offset` to `offset + len - 1`.
`offset` can be negative; and is evaluated as `length(arr - offset);`

`fill(arr, ~offset=-1, ~len=1);` means fill the last element, if the array does not have enough data; `fill` will ignore it

Examples

```
let arr = makeBy(5, (i) => i);

fill(arr, ~offset=2, ~len=2, 9);

arr == [|0, 1, 9, 9, 4|];

fill(arr, ~offset=7, ~len=2, 8);

arr == [|0, 1, 9, 9, 4|];
```

## blit

```
let blit: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit;
```

`blit(~src=v1, ~srcOffset=o1, ~dst=v2, ~dstOffset=o2, ~len);`

copies `len` elements from array `v1`;starting at element number `o1`;to array `v2`, starting at element number `o2`.

It works correctly even if `v1` and `v2` are the same array;and the source and destination chunks overlap.

`offset` can be negative; `-1` means `len - 1`; if `len + offset` is still negative;it will be set as 0

For each of the examples;presume that `v1 == [|10, 11, 12, 13, 14, 15, 16, 17|];` and `v2 == [|20, 21, 22, 23, 24, 25, 26, 27|];`. The result shown is the content of the destination array.

Examples

```
Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v2, ~dstOffset=2, ~len=3)
|. [|20, 21, 14, 15, 16, 25, 26, 27|];

Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v1, ~dstOffset=2, ~len=3)
|. [|10, 11, 14, 15, 16, 15, 16, 17|];
```

## blitUnsafe

```
let blitUnsafe: (~src: array('a), ~srcOffset: int, ~dst: array('a), ~dstOffset: int, ~len: int) => unit;
```

Unsafe blit without bounds checking.

## forEachU

```
let forEachU: (array('a), [@bs] ('a => unit)) => unit;
```

## forEach

```
let forEach: (array('a), 'a => unit) => unit;
```

`forEach(xs, f);`

Call `f` on each element of `xs` from the beginning to end. `f` returns `unit`;so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.

Examples

```
forEach([|"a", "b", "c"|], (x) => Js.log("Item: " ++ x));

/*  prints:
      Item: a
      Item: b
      Item: c
    */
let total = ref(0);

forEach([|1, 2, 3, 4|], (x) => total := total^ + x);

total^ == 1 + 2 + 3 + 4;
```

## mapU

```
let mapU: (array('a), [@bs] ('a => 'b)) => array('b);
```

## map

```
let map: (array('a), 'a => 'b) => array('b);
```

## getByU

```
let getByU: (array('a), [@bs] ('a => bool)) => option('a);
```

## getBy

```
let getBy: (array('a), 'a => bool) => option('a);
```

## getIndexByU

```
let getIndexByU: (array('a), [@bs] ('a => bool)) => option(int);
```

## getIndexBy

```
let getIndexBy: (array('a), 'a => bool) => option(int);
```

## keepU

```
let keepU: (array('a), [@bs] ('a => bool)) => array('a);
```

## keep

```
let keep: (array('a), 'a => bool) => array('a);
```

## keepWithIndexU

```
let keepWithIndexU: (array('a), [@bs] (('a, int) => bool)) => array('a);
```

## keepWithIndex

```
let keepWithIndex: (array('a), ('a, int) => bool) => array('a);
```

## keepMapU

```
let keepMapU: (array('a), [@bs] ('a => option('b))) => array('b);
```

## keepMap

```
let keepMap: (array('a), 'a => option('b)) => array('b);
```

## forEachWithIndexU

```
let forEachWithIndexU: (array('a), [@bs] ((int, 'a) => unit)) => unit;
```

## forEachWithIndex

```
let forEachWithIndex: (array('a), (int, 'a) => unit) => unit;
```

## mapWithIndexU

```
let mapWithIndexU: (array('a), [@bs] ((int, 'a) => 'b)) => array('b);
```

## mapWithIndex

```
let mapWithIndex: (array('a), (int, 'a) => 'b) => array('b);
```

## partitionU

```
let partitionU: (array('a), [@bs] ('a => bool)) => (array('a), array('a));
```

## partition

```
let partition: (array('a), 'a => bool) => (array('a), array('a));
```

## reduceU

```
let reduceU: (array('b), 'a, [@bs] (('a, 'b) => 'a)) => 'a;
```

## reduce

```
let reduce: (array('b), 'a, ('a, 'b) => 'a) => 'a;
```

## reduceReverseU

```
let reduceReverseU: (array('b), 'a, [@bs] (('a, 'b) => 'a)) => 'a;
```

## reduceReverse

```
let reduceReverse: (array('b), 'a, ('a, 'b) => 'a) => 'a;
```

## reduceReverse2U

```
let reduceReverse2U: (array('a), array('b), 'c, [@bs] (('c, 'a, 'b) => 'c)) => 'c;
```

## reduceReverse2

```
let reduceReverse2: (array('a), array('b), 'c, ('c, 'a, 'b) => 'c) => 'c;
```

## reduceWithIndexU

```
let reduceWithIndexU: (array('a), 'b, [@bs] (('b, 'a, int) => 'b)) => 'b;
```

## reduceWithIndex

```
let reduceWithIndex: (array('a), 'b, ('b, 'a, int) => 'b) => 'b;
```

## someU

```
let someU: (array('a), [@bs] ('a => bool)) => bool;
```

## some

```
let some: (array('a), 'a => bool) => bool;
```

## everyU

```
let everyU: (array('a), [@bs] ('a => bool)) => bool;
```

## every

```
let every: (array('a), 'a => bool) => bool;
```

## every2U

```
let every2U: (array('a), array('b), [@bs] (('a, 'b) => bool)) => bool;
```

## every2

```
let every2: (array('a), array('b), ('a, 'b) => bool) => bool;
```

## some2U

```
let some2U: (array('a), array('b), [@bs] (('a, 'b) => bool)) => bool;
```

## some2

```
let some2: (array('a), array('b), ('a, 'b) => bool) => bool;
```

## cmpU

```
let cmpU: (array('a), array('a), [@bs] (('a, 'a) => int)) => int;
```

## cmp

```
let cmp: (array('a), array('a), ('a, 'a) => int) => int;
```

## eqU

```
let eqU: (array('a), array('a), [@bs] (('a, 'a) => bool)) => bool;
```

## eq

```
let eq: (array('a), array('a), ('a, 'a) => bool) => bool;
```

## truncateToLengthUnsafe

```
let truncateToLengthUnsafe: (array('a), int) => unit;
```
