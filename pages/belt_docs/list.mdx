import { make as Layout } from "../../layouts/BeltDocsLayout.bs.js";
export default Layout;

# List

Collection functions for manipulating `list` data structures.

## t('a)

```
type t('a) = list('a);
```

## length

```
let length: t('a) => int;
```

```reason
length(someList);
```

**Example**

```reason
Belt.List.length([1, 2, 3]); /* 3 */
```

## size

```
let size: t('a) => int;
```

**See:** [length](#length)

## head

```
let head: t('a) => option('a);
```

```reason
head(someList);
```

Returns `Some(value)` where `value` is the first element in the list, or `None` if `someList` is an empty list.

**Examples**

```reason
Belt.List.head([]); /* None */

Belt.List.head([1, 2, 3]); /* Some(1) */
```

## headExn

```
let headExn: t('a) => 'a;
```

```reason
head(someList);
```

Same as [head](#head), but raises an exception if `someList` is empty. Use with care.

## tail

```
let tail: t('a) => option(t('a));
```

```reason
tail(someList);
```

Returns `None` if `someList` is empty, otherwise it returns `Some(tail)` where `tail` is everything except the first element of `someList`.

**Example**

```reason
Belt.List.tail([1, 2, 3]); /* Some([2, 3]) */

Belt.List.tail([]); /* None */
```

## tailExn

```
let tailExn: t('a) => t('a);
```

```reason
tailExn(someList);
```

Same as [tail](#tail), but raises an exception if `someList` is empty. Use with care.

## add

```
let add: (t('a), 'a) => t('a);
```

```reason
add(someList, value);
```

Adds `value` to the beginning of `someList`.

**Examples**

```reason
Belt.List.add([2, 3], 1); /* [1, 2, 3] */

Belt.List.add(["World", "!"], "Hello"); /* ["Hello", "World", "!"] */
```

## get

```
let get: (t('a), int) => option('a);
```

```reason
get(someList, index);
```

Return the nth element in `someList`, or `None` if `index` is larger than the length.

**Examples**

```reason
let abc = ["A", "B", "C"];

abc->Belt.List.get(1); /* Some("B") */

abc->Belt.List.get(4); /* None */
```

## getExn

```
let getExn: (t('a), int) => 'a;
```

```reason
getExn(someList, index);
```

Same as [get](#get), but raises an exception if `index` is larger than the length. Use with care.

## make

```
let make: (int, 'a) => t('a);
```

```reason
make(numItems, v);
```

Returns a list of length `numItems` with each element filled with value `v`. Returns an empty list if `numItems` is negative.

**Example**

```reason
Belt.List.make(3, 1); /* [1, 1, 1] */
```

## makeBy

```
let makeBy: (int, int => 'a) => t('a);
```

```reason
makeBy(numItems, f);
```

Return a list of length `numItems` with element `i` initialized with `f(i)`.
Returns an empty list if `numItems` is negative.

**Examples**

```reason
Belt.List.makeBy(5, i => i); /* [0, 1, 2, 3, 4] */

Belt.List.makeBy(5, i => i * i); /* [0, 1, 4, 9, 16] */
```

## makeByU

```
let makeByU: (int, [@bs] (int => 'a)) => t('a);
```

Uncurried version of [makeBy](#makeBy)

## shuffle

```
let shuffle: t('a) => t('a);
```

```reason
shuffle(someList);
```

Returns a new list in random order.

**Example**

```reason
Belt.List.shuffle([1, 2, 3]); /* [2, 1, 3] */
```

## drop

```
let drop: (t('a), int) => option(t('a));
```

```reason
drop(someList, n);
```

Return a new list, dropping the first `n` elements. Returns `None` if `someList` has fewer than `n` elements.

**Examples**

```reason
[1, 2, 3]->Belt.List.drop(2); /* Some([3]) */

[1, 2, 3]->Belt.List.drop(3); /* Some([]) */

[1, 2, 3]->Belt.List.drop(4); /* None */
```

## take

```
let take: (t('a), int) => option(t('a));
```

```reason
take(someList, n);
```

Returns a list with the first `n` elements from `someList`, or `None` if `someList` has fewer than `n` elements.

**Examples**

```reason
[1, 2, 3]->Belt.List.take(1); /* Some([1]) */

[1, 2, 3]->Belt.List.take(2); /* Some([1, 2]) */

[1, 2, 3]->Belt.List.take(4); /* None */
```

## splitAt

```
let splitAt: (t('a), int) => option((list('a), list('a)));
```

```reason
splitAt(someList, index);
```

Split the list `someList` at `index`. Returns `None` when the length of `someList` is less than `index`.

**Examples**

```reason
["Hello", "World"]->Belt.List.splitAt(1); /* Some((["Hello"], ["World"])) */

[0, 1, 2, 3, 4]->Belt.List.splitAt(2); /* Some(([0, 1], [2, 3, 4])) */
```

## concat

```
let concat: (t('a), t('a)) => t('a);
```

```reason
concat(firstList, secondList);
```

Returns the list obtained by adding `secondList` after `firstList`.

**Example**

```reason
Belt.List.concat([1, 2, 3], [4, 5]); /* [1, 2, 3, 4, 5] */
```

## concatMany

```
let concatMany: array(t('a)) => t('a);
```

```reason
concatMany(a);
```

Returns the list obtained by concatenating all the lists in array `a`, in order.

**Example**

```reason
Belt.List.concatMany([|[1, 2, 3], [], [3], [4]|]); /* [1, 2, 3, 3, 4] */
```

## reverseConcat

```
let reverseConcat: (t('a), t('a)) => t('a);
```

```reason
reverseConcat(firstList, secondList);
```

Equivalent to writing:

```reason
concat(reverse(firstList), secondList);
```

**Example**

```reason
Belt.List.reverseConcat([1, 2], [3, 4]); /* [2, 1, 3, 4] */
```

## flatten

```
let flatten: t(t('a)) => t('a);
```

```reason
flatten(ls);
```

Return the list obtained by concatenating all the lists in list `ls`, in order.

**Example**

```reason
Belt.List.flatten([[1, 2, 3], [], [3], [4]]); /* [1, 2, 3, 3, 4] */
```

## map

```
let map: (t('a), 'a => 'b) => t('b);
```

```reason
map(someList, f);
```

Returns a new list with `f` applied to each element of `someList`.

**Example**

```reason
[1, 2]->Belt.List.map(x => x + 1); /* [3, 4] */
```

## mapU

```
let mapU: (t('a), [@bs] ('a => 'b)) => t('b);
```

Uncurried version of [map](#map).

## zip

```
let zip: (t('a), t('b)) => t(('a, 'b));
```

```reason
zip(firstList, secondList);
```

Returns a list of pairs from the two lists with the length of the shorter list.

**Example**

```reason
Belt.List.zip([1, 2], [3, 4, 5]); /* [(1, 3), (2, 4)] */
```

## zipBy

```
let zipBy: (t('a), t('b), ('a, 'b) => 'c) => t('c);
```

```reason
zipBy(firstList, secondList, f);
```

**See:** [zip](#zip)

Equivalent to:

```reason
zip(firstList, secondList) |> List.map(((x, y)) => f(x, y));
```

**Example**

```reason
Belt.List.zipBy([1, 2, 3], [4, 5], (a, b) => 2 * a + b); /* [6, 9] */
```

## zipByU

```
let zipByU: (t('a), t('b), [@bs] (('a, 'b) => 'c)) => t('c);
```

Uncurried version of [zipBy](#zipBy).

## mapWithIndex

```
let mapWithIndex: (t('a), (int, 'a) => 'b) => t('b);
```

```reason
mapWithIndex(someList, f);
```

Applies `f` to each element of `someList`.
Function `f` takes two arguments: the index starting from 0 and the element from `someList`, in that order.

**Example**

```reason
[1, 2, 3]->Belt.List.mapWithIndex((index, x) => index + x); /* [1, 3, 5] */
```

## mapWithIndexU

```
let mapWithIndexU: (t('a), [@bs] ((int, 'a) => 'b)) => t('b);
```

Uncurried version of [mapWithIndex](#mapWithIndex).

## fromArray

```
let fromArray: array('a) => t('a);
```

```reason
fromArray(someArray);
```

Converts the given array to a list.

**Examples**

```reason
Belt.List.fromArray([|1, 2, 3|]); /* [1, 2, 3] */
```

## toArray

```
let toArray: t('a) => array('a);
```

```reason
toArray(someList);
```

Converts the given list to an array.

**Example**

```reason
Belt.List.toArray([1, 2, 3]); /* [|1, 2, 3|] */
```

## reverse

```
let reverse: t('a) => t('a);
```

```reason
reverse(someList);
```

Returns a new list whose elements are those of `someList` in reversed order.

**Example**

```reason
Belt.List.reverse([1, 2, 3]); /* [3, 2, 1] */
```

## mapReverse

```
let mapReverse: (t('a), 'a => 'b) => t('b);
```

```reason
mapReverse(someList, f);
```

Equivalent to:

```reason
map(someList, f)->reverse;
```

**Example**

```reason
[3, 4, 5]->Belt.List.mapReverse(x => x * x); /* [25, 16, 9] */
```

## mapReverseU

```
let mapReverseU: (t('a), [@bs] ('a => 'b)) => t('b);
```

Uncurried version of [mapReverse](#mapReverse).

## forEach

```
let forEach: (t('a), 'a => 'b) => unit;
```

```reason
forEach(xs, f);
```

Call `f` on each element of `someList` from the beginning to end.
`f` returns `unit`, so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.

**Example**

```reason
Belt.List.forEach(["a", "b", "c"], x => Js.log("Item: " ++ x));
/*  prints:
      Item: a
      Item: b
      Item: c
    */
```

## forEachU

```
let forEachU: (t('a), [@bs] ('a => 'b)) => unit;
```

Uncurried version of [forEach](#forEach).

## forEachWithIndex

```
let forEachWithIndex: (t('a), (int, 'a) => 'b) => unit;
```

```reason
forEachWithIndex(xs, f);
```

Call `f` on each element of `someList` from beginning to end.
Function `f` takes two arguments: the index starting from 0 and the element from `someList`. `f` returns `unit`.

**Example**

```reason
forEachWithIndex(["a", "b", "c"], (index, x) => Js.log("Item " ++ string_of_int(index) ++ " is " ++ x));
/*  prints:
      Item 0 is a
      Item 1 is b
      Item 2 is cc
    */
```

## forEachWithIndexU

```
let forEachWithIndexU: (t('a), [@bs] ((int, 'a) => 'b)) => unit;
```

Uncurried version of [forEachWithIndex](#forEachWithIndex).

## reduce

```
let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b;
```

```reason
reduce(someList, initialValue, f);
```

Applies `f` to each element of `someList` from beginning to end. Function `f` has two parameters: the item from the list and an “accumulator”, which starts with a value of `initialValue`. reduce returns the final value of the accumulator.

**Examples**

```reason
[1, 2, 3, 4]->Belt.List.reduce(0, (+)); /* 10 */

/* same as */

[1, 2, 3, 4]->Belt.List.reduce(0, (acc, item) => acc + item); /* 10 */
```

## reduceU

```
let reduceU: (t('a), 'b, [@bs] (('b, 'a) => 'b)) => 'b;
```

Uncurried version of [reduce](#reduce).

## reduceWithIndex

```
let reduceWithIndex: (t('a), 'b, ('b, 'a, int) => 'b) => 'b;
```

```reason
reduceWithIndex(someList, initialValue, f);
```

Applies `f` to each element of `someList` from beginning to end. Function `f` has three parameters: the item from the list and an “accumulator”, which starts with a value of `initialValue` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.

**Example**

```reason
[1, 2, 3, 4]->Belt.List.reduceWithIndex(0, (acc, item, index) => acc + item + index); /* 16 */
```

## reduceWithIndexU

```
let reduceWithIndexU: (t('a), 'b, [@bs] (('b, 'a, int) => 'b)) => 'b;
```

Uncurried version of [reduceWithIndex](#reduceWithIndex).

## reduceReverse

```
let reduceReverse: (t('a), 'b, ('b, 'a) => 'b) => 'b;
```

```reason
reduceReverse(someList, f);
```

Works like [reduce](#reduce), except that function `f` is applied to each item of `someList` from the last back to the first.

**Examples**

```reason
[1, 2, 3, 4]->Belt.List.reduceReverse(0, (+)); /* 10 */

[1, 2, 3, 4]->Belt.List.reduceReverse(10, (-)); /* 0 */

[1, 2, 3, 4]->Belt.List.reduceReverse([], add); /* [1, 2, 3, 4] */
```

## reduceReverseU

```
let reduceReverseU: (t('a), 'b, [@bs] (('b, 'a) => 'b)) => 'b;
```

Uncurried version of [reduceReverse](#reduceReverse).

## mapReverse2U

```
let mapReverse2U: (t('a), t('b), [@bs] (('a, 'b) => 'c)) => t('c);
```

## mapReverse2

```
let mapReverse2: (t('a), t('b), ('a, 'b) => 'c) => t('c);
```

```reason
mapReverse2(firstList, secondList, f);
```

Equivalent to:

```reason
zipBy(xs, ys, f)->reverse;
```

**Example**

```reason
Belt.List.mapReverse2([1, 2, 3], [1, 2], (+)); /* [4, 2] */
```

## forEach2

```
let forEach2: (t('a), t('b), ('a, 'b) => 'c) => unit;
```

```reason
forEach2(firstList, secondList, f);
```

Stops at the length of the shorter list.

**Example**

```reason
Belt.List.forEach2(["Z", "Y"], ["A", "B", "C"], (x, y) => Js.log2(x, y));

/* prints:
"Z" "A"
"Y" "B"
*/
```

## forEach2U

```
let forEach2U: (t('a), t('b), [@bs] (('a, 'b) => 'c)) => unit;
```

Uncurried version of [forEach2](#forEach2).

## reduce2

```
let reduce2: (t('b), t('c), 'a, ('a, 'b, 'c) => 'a) => 'a;
```

```reason
reduce2(firstList, secondList, initialValue, f);
```

Applies `f` to each element of `firstList` and `secondList` from beginning to end. Stops with the shorter list. Function `f` has three parameters: an “accumulator” which starts with a value of `initialValue`, an item from `firstList`, and an item from `secondList`. `reduce2` returns the final value of the accumulator.

**Example**

```reason
Belt.List.reduce2([1, 2, 3], [4, 5], 0, (acc, x, y) => acc + x * x + y); /* 0 + (1 * 1 + 4) + (2 * 2 + 5) */
```

## reduce2U

```
let reduce2U: (t('b), t('c), 'a, [@bs] (('a, 'b, 'c) => 'a)) => 'a;
```

Uncurried version of [reduce2](#reduce2).

## reduceReverse2

```
let reduceReverse2: (t('a), t('b), 'c, ('c, 'a, 'b) => 'c) => 'c;
```

```reason
reduceReverse2(firstList, secondList, initialValue, f);
```

Applies `f` to each element of `firstList` and `secondList` from end to beginning. Stops with the shorter list. Function `f` has three parameters: an “accumulator” which starts with a value of init, an item from `firstList`, and an item from `secondList`. `reduce2` returns the final value of the accumulator.

**Example**

```reason
Belt.List.reduceReverse2([1, 2, 3], [4, 5], 0, (acc, x, y) => acc + x * x + y); /*  + (1 * 1 + 4) + (2 * 2 + 5) */

```

## reduceReverse2U

```
let reduceReverse2U: (t('a), t('b), 'c, [@bs] (('c, 'a, 'b) => 'c)) => 'c;
```

Uncurried version of [reduceReverse2](#reduceReverse2).

## every

```
let every: (t('a), 'a => bool) => bool;
```

```reason
every(someList, p);
```

Returns `true` if all elements satisfy `p`, where `p` is a predicate: a function taking an element and returning a bool.

**Examples**

```reason
let isBelow10 = value => value < 10;

[1, 9, 8, 2]->Belt.List.every(isBelow10); /* true */

[1, 99, 8, 2]->Belt.List.every(isBelow10); /* false */
```

## everyU

```
let everyU: (t('a), [@bs] ('a => bool)) => bool;
```

Uncurried version of [every](#every).

## some

```
let some: (t('a), 'a => bool) => bool;
```

```reason
some(someList, p);
```

Returns `true` if at least _one_ of the elements in `someList` satifies `p`, where `p` is a predicate: a function taking an element and returning a bool.

**Examples**

```reason
let isAbove100 = value => value > 100;

[101, 1, 2, 3]->Belt.List.some(isAbove100); /* true */

[1, 2, 3, 4]->Belt.List.some(isAbove100); /* false */
```

## someU

```
let someU: (t('a), [@bs] ('a => bool)) => bool;
```

Uncurried version of [some](#some).

## every2

```
let every2: (t('a), t('b), ('a, 'b) => bool) => bool;
```

```reason
every2(xs, ys, p);
```

Returns `true` if predicate `p(xi, yi)` is `true` for all pairs of elements up to the shorter length (i.e. `min(length(xs), length(ys))`)

**Examples**

```reason
Belt.List.every2([1, 2, 3], [0, 1], (>)); /* true */

Belt.List.every2([], [1], (x, y) => x > y); /* true */

Belt.List.every2([2, 3], [1], (x, y) => x > y); /* true */

Belt.List.every2([0, 1], [5, 0], (x, y) => x > y); /* false */
```

## every2U

```
let every2U: (t('a), t('b), [@bs] (('a, 'b) => bool)) => bool;
```

Uncurried version of [every2](#every2).

## some2

```
let some2: (t('a), t('b), ('a, 'b) => bool) => bool;
```

```reason
some2(xs, ys, p);
```

Returns `true` if `p(xi, yi)` is true for any pair of elements up to the shorter length (i.e. `min(length(xs), length(ys))`)

## some2U

```
let some2U: (t('a), t('b), [@bs] (('a, 'b) => bool)) => bool;
```

Uncurried version of [some2](#some2).

## cmpByLength

```
let cmpByLength: (t('a), t('a)) => int;
```

```reason
cmpByLength(firstList, secondList);
```

Compare two lists solely by length. Returns `-1` if `length(firstList)` is less than `length(secondList)`, `0` if `length(firstList)` equals `length(secondList)`, and `1` if `length(firstList)` is greater than `length(secondList)`.

**Examples**

```reason
Belt.List.cmpByLength([1, 2], [3, 4, 5, 6]); /* (-1) */

Belt.List.cmpByLength([1, 2, 3], [4, 5, 6]); /* = 0 */

Belt.List.cmpByLength([1, 2, 3, 4], [5, 6]); /* = 1 */
```

## cmp

```
let cmp: (t('a), t('a), ('a, 'a) => int) => int;
```

**Examples**

```reason
cmp(firstList, secondList, compareFn);
```

Compare elements one by one `f(x, y)`. `f` returns a negative number if `x` is "less than" `y`, zero if `x`is "equal to" `y`, a positive number if `x`is "greater than" `y`.

The comparison returns the first non-zero result of `f`, or zero if `f` returns zero for all `x` and `y`.
If all items have compared equal, but `firstList` is exhausted first, return `-1`. (`firstList` is shorter).
If all items have compared equal, but `secondList` is exhausted first, return `1` (`firstList` is longer).

```reason
Belt.List.cmp([3], [3, 7], (a, b) => compare(a, b)); /* (-1) */

Belt.List.cmp([5, 3], [5], (a, b) => compare(a, b)); /* 1 */

Belt.List.cmp([|1, 3, 5|], [|1, 4, 2|], (a, b) => compare(a, b)); /* (-1) */

Belt.List.cmp([|1, 3, 5|], [|1, 2, 3|], (a, b) => compare(a, b)); /* 1 */

Belt.List.cmp([|1, 3, 5|], [|1, 3, 5|], (a, b) => compare(a, b)); /* 0 */
```

**Please note:** The total ordering of List is different from Array,
for Array, we compare the length first and, only if the lengths are equal, elements one by one.
For lists, we just compare elements one by one.

## cmpU

```
let cmpU: (t('a), t('a), [@bs] (('a, 'a) => int)) => int;
```

Uncurried version of [cmp](#cmp).

## eq

```
let eq: (t('a), t('a), ('a, 'a) => bool) => bool;
```

```reason
eq(firstList, secondList, eqElem);
```

Check equality of `firstList` and `secondList` using `eqElem` for equality on elements, where `eqElem` is a function that returns `true` if items `x` and `y` meet some criterion for equality, `false` otherwise. eq `false` if length of `firstList` and `secondList` are not the same.

**Examples**

```reason
Belt.List.eq([1, 2, 3], [1, 2], (==)); /* false */

Belt.List.eq([1, 2], [1, 2], (==)); /* true */

Belt.List.eq([1, 2, 3], [(-1), (-2), (-3)], (a, b) => abs(a) == abs(b)); /* true */
```

## eqU

```
let eqU: (t('a), t('a), [@bs] (('a, 'a) => bool)) => bool;
```

Uncurried version of [eqU](#eqU).

## has

```
let has: (t('a), 'b, ('a, 'b) => bool) => bool;
```

```reason
has(someList, eqFunction);
```

Returns `true` if the list contains at least one element for which `eqFunction(x)` returns true.

**Examples**

```reason
[1, 2, 3]->Belt.List.has(2, (==)); /* true */

[1, 2, 3]->Belt.List.has(4, (==)); /* false */

[(-1), (-2), (-3)]->Belt.List.has(2, (a, b) => abs(a) == abs(b)); /* true */
```

## hasU

```
let hasU: (t('a), 'b, [@bs] (('a, 'b) => bool)) => bool;
```

Uncurried version of [has](#has).

## getBy

```
let getBy: (t('a), 'a => bool) => option('a);
```

```reason
getBy(someList, p);
```

Returns `Some(value)` for the first value in `someList` that satisifies the predicate function `p`. Returns `None` if no element satisifies the function.

**Examples**

```reason
Belt.List.getBy([1, 4, 3, 2], x => x > 3); /* Some(4) */

Belt.List.getBy([1, 4, 3, 2], x => x > 4); /* None */
```

## getByU

```
let getByU: (t('a), [@bs] ('a => bool)) => option('a);
```

Uncurried version of [getBy](#getBy).

## keep

```
let keep: (t('a), 'a => bool) => t('a);
```

```reason
keep(someList, p);
```

Returns a list of all elements in `someList` which satisfy the predicate function `p`.

**Examples**

```reason
let isEven = x => x mod 2 == 0;

Belt.List.keep([1, 2, 3, 4], isEven); /* [2, 4] */

Belt.List.keep([None, Some(2), Some(3), None], Belt.Option.isSome); /* [Some(2), Some(3)] */
```

## keepU

```
let keepU: (t('a), [@bs] ('a => bool)) => t('a);
```

Uncurried version of [keep](#keep).

## filter

```
let filter: (t('a), 'a => bool) => t('a);
```

```reason
filter(someList, p);
```

Returns a list of all elements in `someList` which satisfy the predicate function `p`.

**Examples**

```reason
let isEven = x => x mod 2 == 0;

Belt.List.filter([1, 2, 3, 4], isEven); /* [2, 4] */

Belt.List.filter([None, Some(2), Some(3), None], Belt.Option.isSome); /* [Some(2), Some(3)] */
```

## keepWithIndex

```
let keepWithIndex: (t('a), ('a, int) => bool) => t('a);
```

```reason
keepWithIndex(someList, p);
```

Returns a list of all elements in `someList` which satisfy the predicate function `p`.

**Examples**

```reason
let isEven = x => x mod 2 == 0;

Belt.List.keepWithIndex([1, 2, 3, 4], (_x, index) => isEven(index)); /* [1, 3] */
```

## keepWithIndexU

```
let keepWithIndexU: (t('a), [@bs] (('a, int) => bool)) => t('a);
```

Uncurried version of [keepWithIndex](#keepWithIndex).

## filterWithIndex

```
let filterWithIndex: (t('a), ('a, int) => bool) => t('a);
```

```language
filterWithIndex(someList, p);
```

Returns a list of all elements in `someList` which satisfy the predicate function `p`.

**Examples**

```reason
let isEven = x => x mod 2 == 0;

Belt.List.filterWithIndex([1, 2, 3, 4], (_x, index) => isEven(index)); /* [1, 3] */
```

## keepMap

```
let keepMap: (t('a), 'a => option('b)) => t('b);
```

```reason
keepMap(someList, f);
```

Applies `f` to each element of `someList`. If `f(xi)` returns `Some(value)`, then `value` is _kept_ in the resulting list.
If `f(xi)` returns `None`, the element is _not_ retained in the result.

**Examples**

```reason
let isEven = x => x mod 2 == 0;

[1, 2, 3, 4]
->Belt.List.keepMap(x =>
    if (isEven(x)) {
      Some(x);
    } else {
      None;
    }
  ); /* [2, 4] */

[Some(1), Some(2), None]->Belt.List.keepMap(x => x); /* [1, 2] */
```

## keepMapU

```
let keepMapU: (t('a), [@bs] ('a => option('b))) => t('b);
```

Uncurried version of [keepMap](#keepMap).

## partition

```
let partition: (t('a), 'a => bool) => (t('a), t('a));
```

```reason
partition(someList, p);
```

Creates a pair of lists; the first list consists of all elements of `someList` that satisfy the predicate function `p`; the second list consists of all elements of `someList` that _do not_ satisfy `p`.

In other words:

```
([elementsThatSatisfies], [elementsThatDoesNotSatisfy]);
```

**Examples**

```reason
Belt.List.partition([1, 2, 3, 4], x => x > 2); /* ([3, 4], [1, 2]) */
```

## partitionU

```
let partitionU: (t('a), [@bs] ('a => bool)) => (t('a), t('a));
```

Uncurried version of [partition](#partition).

## unzip

```
let unzip: t(('a, 'b)) => (t('a), t('b));
```

```reason
unzip(someList);
```

Takes a list of pairs and creates a pair of lists. The first list contains all the first items of the pairs; the second list contains all the second items.

**Examples**

```reason
Belt.List.unzip([(1, 2), (3, 4)]); /* ([1, 3], [2, 4]) */

Belt.List.unzip([("H", "W"), ("e", "o"), ("l", "r"), ("l", "l"), ("o", "d"), (" ", "!")]);
/* (["H", "e", "l", "l", "o", " "], ["W", "o", "r", "l", "d", "!"]); */
```

## getAssoc

```
let getAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => option('c);
```

```reason
getAssoc(someList, k, eqFunction);
```

Return the second element of a pair in `someList` where the first element equals `k` as per the predicate function `eq`, or `None` if not found.

**Examples**

```reason
[(1, "a"), (2, "b"), (3, "c")]->Belt.List.getAssoc(3, (==)); /* Some("c") */

[(9, "morning"), (15, "afternoon"), (22, "night")]
->Belt.List.getAssoc(15, (k, item) => k /* 15 */ == item /* 9, 5, 22 */);
/* Some("afternoon"); */
```

## getAssocU

```
let getAssocU: (t(('a, 'c)), 'b, [@bs] (('a, 'b) => bool)) => option('c);
```

Uncurried version of [getAssoc](#getAssoc).

## hasAssoc

```
let hasAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => bool;
```

```reason
hasAssoc(someList, k, eqFunction);
```

Returns `true` if there is a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`.

**Examples**

```reason
[(1, "a"), (2, "b"), (3, "c")]->Belt.List.hasAssoc(1, (==)); /* true */

[(9, "morning"), (15, "afternoon"), (22, "night")]
->Belt.List.hasAssoc(25, (k, item) => k /* 25 */ == item /* 9, 5, 22 */); /* false */
```

## hasAssocU

```
let hasAssocU: (t(('a, 'c)), 'b, [@bs] (('a, 'b) => bool)) => bool;
```

Uncurried version of [hasAssoc](#hasAssoc).

## removeAssoc

```
let removeAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => t(('a, 'c));
```

```reason
removeAssoc(someList, k, eqFunction);
```

Return a list after removing the first pair whose first value is `k` per the equality predicate `eqFunction`; if not found, return a new list identical to `someList`.

**Example**

```reason
[(1, "a"), (2, "b"), (3, "c")]->Belt.List.removeAssoc(1, (==)); /* [(2, "b"), (3, "c")] */

[(9, "morning"), (15, "afternoon"), (22, "night")]
->Belt.List.removeAssoc(9, (k, item) => k /* 9 */ == item /* 9, 5, 22 */);
/* [(15, "afternoon"), (22, "night")] */
```

## removeAssocU

```
let removeAssocU: (t(('a, 'c)), 'b, [@bs] (('a, 'b) => bool)) => t(('a, 'c));
```

Uncurried version of [removeAssoc](#removeAssoc).

## setAssoc

```
let setAssoc: (t(('a, 'c)), 'a, 'c, ('a, 'a) => bool) => t(('a, 'c));
```

```reason
setAssoc(someList, k, v, eq);
```

If `k` exists in `someList` by satisfying the `eq` predicate, return a new list with the key and value replaced by the new `k` and `v`; otherwise, return a new list with the pair `k`, `v` added to the head of `someList`.

**Examples**

```reason
[(1, "a"), (2, "b"), (3, "c")]->Belt.List.setAssoc(2, "x", (==)); /* [(1, "a"), (2, "x"), (3, "c")]; */

[(1, "a"), (3, "c")]->Belt.List.setAssoc(2, "b", (==)); /* [(2, "b"), (1, "a"), (3, "c")] */

[(9, "morning"), (3, "morning?!"), (22, "night")]
->Belt.List.setAssoc(15, "afternoon", (a, b) => a mod 12 == b mod 12);
/* [(9, "morning"), (15, "afternoon"), (22, "night")] */
```

**Please note**

In the last example, since:

```reason
15 mod 12
```

equals

```reason
3 mod 12
```

Both the key _and_ the value are replaced in the list.

## setAssocU

```
let setAssocU: (t(('a, 'c)), 'a, 'c, [@bs] (('a, 'a) => bool)) => t(('a, 'c));
```

Uncurried version of [setAssoc](#setAssoc).

## sort

```
let sort: (t('a), ('a, 'a) => int) => t('a);
```

```reason
sort(someList);
```

Returns a sorted list.

**Example**

```reason
Belt.List.sort([5, 4, 9, 3, 7], (a, b) => a - b); /* [3, 4, 5, 7, 9] */
```

## sortU

```
let sortU: (t('a), [@bs] (('a, 'a) => int)) => t('a);
```

Uncurried version of [sort](#sort).
