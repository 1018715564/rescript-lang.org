import { make as Layout } from "../../layouts/BeltDocsLayout.bs.js";
export default Layout;

# List

Collection functions for manipulating `list` data structures.

## t('a)

```
type t('a) = list('a);
```

## length

```
let length: t('a) => int;
```

```reason
length(someList);
```

**Example**

```reason
Belt.List.length([1, 2, 3]); /* 3 */
```

## size

```
let size: t('a) => int;
```

**See:** [length](#length)

## head

```
let head: t('a) => option('a);
```

```reason
head(someList);
```

Returns `Some(value)` where `value` is the first element in the list, or `None` if `someList` is an empty list.

**Examples**

```reason
Belt.List.head([]); /* None */

Belt.List.head([1, 2, 3]); /* Some(1) */
```

## headExn

```
let headExn: t('a) => 'a;
```

```reason
head(someList);
```

Same as [head](#head), but raises an exception if `someList` is empty. Use with care.

## tail

```
let tail: t('a) => option(t('a));
```

```reason
tail(someList);
```

Returns `None` if `someList` is empty, otherwise it returns `Some(tail)` where `tail` is everything except the first element of `someList`.

**Example**

```reason
Belt.List.tail([1, 2, 3]); /* Some([2, 3]) */

Belt.List.tail([]); /* None */
```

## tailExn

```
let tailExn: t('a) => t('a);
```

```reason
tailExn(someList);
```

Same as [tail](#tail), but raises an exception if `someList` is empty. Use with care.

## add

```
let add: (t('a), 'a) => t('a);
```

```reason
add(someList, value);
```

Adds `value` to the beginning of `someList`.

**Examples**

```reason
Belt.List.add([2, 3], 1); /* [1, 2, 3] */

Belt.List.add(["World", "!"], "Hello"); /* ["Hello", "World", "!"] */
```

## get

```
let get: (t('a), int) => option('a);
```

```reason
get(someList, index);
```

Return the nth element in `someList`, or `None` if `index` is larger than the length.

**Examples**

```reason
let abc = ["A", "B", "C"];

abc->Belt.List.get(1); /* Some("B") */

abc->Belt.List.get(4); /* None */
```

## getExn

```
let getExn: (t('a), int) => 'a;
```

```reason
getExn(someList, index);
```

Same as [get](#get), but raises an exception if `index` is larger than the length. Use with care.

## make

```
let make: (int, 'a) => t('a);
```

```reason
make(numItems, v);
```

Returns a list of length `numItems` with each element filled with value `v`. Returns an empty list if `numItems` is negative.

**Example**

```reason
Belt.List.make(3, 1); /* [1, 1, 1] */
```

## makeBy

```
let makeBy: (int, int => 'a) => t('a);
```

```reason
makeBy(numItems, f);
```

Return a list of length `numItems` with element `i` initialized with `f(i)`.
Returns an empty list if `numItems` is negative.

**Examples**

```reason
Belt.List.makeBy(5, i => i); /* [0, 1, 2, 3, 4] */

Belt.List.makeBy(5, i => i * i); /* [0, 1, 4, 9, 16] */
```

## makeByU

```
let makeByU: (int, [@bs] (int => 'a)) => t('a);
```

Uncurried version of [makeBy](#makeBy)

## shuffle

```
let shuffle: t('a) => t('a);
```

```reason
shuffle(someList);
```

Returns a new list in random order.

**Example**

```reason
Belt.List.shuffle([1, 2, 3]); /* [2, 1, 3] */
```

## drop

```
let drop: (t('a), int) => option(t('a));
```

```reason
drop(someList, n);
```

Return a new list, dropping the first `n` elements. Returns `None` if `someList` has fewer than `n` elements.

**Examples**

```reason
[1, 2, 3]->Belt.List.drop(2); /* Some([3]) */

[1, 2, 3]->Belt.List.drop(3); /* Some([]) */

[1, 2, 3]->Belt.List.drop(4); /* None */
```

## take

```
let take: (t('a), int) => option(t('a));
```

```reason
take(someList, n);
```

Returns a list with the first `n` elements from `someList`, or `None` if `someList` has fewer than `n` elements.

**Examples**

```reason
[1, 2, 3]->Belt.List.take(1); /* Some([1]) */

[1, 2, 3]->Belt.List.take(2); /* Some([1, 2]) */

[1, 2, 3]->Belt.List.take(4); /* None */
```

## splitAt

```
let splitAt: (t('a), int) => option((list('a), list('a)));
```

```reason
splitAt(someList, index);
```

Split the list `someList` at `index`. Returns `None` when the length of `someList` is less than `index`.

**Examples**

```reason
["Hello", "World"]->Belt.List.splitAt(1); /* Some((["Hello"], ["World"])) */

[0, 1, 2, 3, 4]->Belt.List.splitAt(2); /* Some(([0, 1], [2, 3, 4])) */
```

## concat

```
let concat: (t('a), t('a)) => t('a);
```

```reason
concat(firstList, secondList);
```

Returns the list obtained by adding `secondList` after `firstList`.

**Example**

```reason
Belt.List.concat([1, 2, 3], [4, 5]); /* [1, 2, 3, 4, 5] */
```

## concatMany

```
let concatMany: array(t('a)) => t('a);
```

```reason
concatMany(a);
```

Returns the list obtained by concatenating all the lists in array `a`, in order.

**Example**

```reason
Belt.List.concatMany([|[1, 2, 3], [], [3], [4]|]); /* [1, 2, 3, 3, 4] */
```

## reverseConcat

```
let reverseConcat: (t('a), t('a)) => t('a);
```

```reason
reverseConcat(firstList, secondList);
```

Equivalent to writing:

```reason
concat(reverse(firstList), secondList);
```

**Example**

```reason
Belt.List.reverseConcat([1, 2], [3, 4]); /* [2, 1, 3, 4] */
```

## flatten

```
let flatten: t(t('a)) => t('a);
```

```reason
flatten(ls);
```

Return the list obtained by concatenating all the lists in list `ls`, in order.

**Example**

```reason
Belt.List.flatten([[1, 2, 3], [], [3], [4]]); /* [1, 2, 3, 3, 4] */
```

## map

```
let map: (t('a), 'a => 'b) => t('b);
```

```reason
map(someList, f);
```

Returns a new list with `f` applied to each element of `someList`.

**Example**

```reason
[1, 2]->Belt.List.map(x => x + 1); /* [3, 4] */
```

## mapU

```
let mapU: (t('a), [@bs] ('a => 'b)) => t('b);
```

Uncurried version of [map](#map).

## zip

```
let zip: (t('a), t('b)) => t(('a, 'b));
```

```reason
zip(firstList, secondList);
```

Returns a list of pairs from the two lists with the length of the shorter list.

**Example**

```reason
Belt.List.zip([1, 2], [3, 4, 5]); /* [(1, 3), (2, 4)] */
```

## zipBy

```
let zipBy: (t('a), t('b), ('a, 'b) => 'c) => t('c);
```

```reason
zipBy(firstList, secondList, f);
```

**See:** [zip](#zip)

Equivalent to:

```reason
zip(firstList, secondList) |> List.map(((x, y)) => f(x, y));
```

**Example**

```reason
Belt.List.zipBy([1, 2, 3], [4, 5], (a, b) => 2 * a + b); /* [6, 9] */
```

## zipByU

```
let zipByU: (t('a), t('b), [@bs] (('a, 'b) => 'c)) => t('c);
```

Uncurried version of [zipBy](#zipBy).

## mapWithIndex

```
let mapWithIndex: (t('a), (int, 'a) => 'b) => t('b);
```

```reason
mapWithIndex(someList, f);
```

Applies `f` to each element of `someList`.
Function `f` takes two arguments: the index starting from 0 and the element from `someList`, in that order.

**Example**

```reason
[1, 2, 3]->Belt.List.mapWithIndex((index, x) => index + x); /* [1, 3, 5] */
```

## mapWithIndexU

```
let mapWithIndexU: (t('a), [@bs] ((int, 'a) => 'b)) => t('b);
```

Uncurried version of [mapWithIndex](#mapWithIndex).

## fromArray

```
let fromArray: array('a) => t('a);
```

```reason
fromArray(someArray);
```

Converts the given array to a list.

**Examples**

```reason
Belt.List.fromArray([|1, 2, 3|]); /* [1, 2, 3] */
```

## toArray

```
let toArray: t('a) => array('a);
```

```reason
toArray(someList);
```

Converts the given list to an array.

**Example**

```reason
Belt.List.toArray([1, 2, 3]); /* [|1, 2, 3|] */
```

## reverse

```
let reverse: t('a) => t('a);
```

```reason
reverse(someList);
```

Returns a new list whose elements are those of `someList` in reversed order.

**Example**

```reason
Belt.List.reverse([1, 2, 3]); /* [3, 2, 1] */
```

## mapReverse

```
let mapReverse: (t('a), 'a => 'b) => t('b);
```

```reason
mapReverse(someList, f);
```

Equivalent to:

```reason
map(someList, f)->reverse;
```

**Example**

```reason
[3, 4, 5]->Belt.List.mapReverse(x => x * x); /* [25, 16, 9] */
```

## mapReverseU

```
let mapReverseU: (t('a), [@bs] ('a => 'b)) => t('b);
```

Uncurried version of [mapReverse](#mapReverse).

## forEach

```
let forEach: (t('a), 'a => 'b) => unit;
```

```reason
forEach(xs, f);
```

Call `f` on each element of `someList` from the beginning to end.
`f` returns `unit`, so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.

**Example**

```reason
Belt.List.forEach(["a", "b", "c"], x => Js.log("Item: " ++ x));
/*  prints:
      Item: a
      Item: b
      Item: c
    */
```

## forEachU

```
let forEachU: (t('a), [@bs] ('a => 'b)) => unit;
```

Uncurried version of [forEach](#forEach).

## forEachWithIndex

```
let forEachWithIndex: (t('a), (int, 'a) => 'b) => unit;
```

```reason
forEachWithIndex(xs, f);
```

Call `f` on each element of `someList` from beginning to end.
Function `f` takes two arguments: the index starting from 0 and the element from `someList`. `f` returns `unit`.

**Example**

```reason
forEachWithIndex(["a", "b", "c"], (index, x) => Js.log("Item " ++ string_of_int(index) ++ " is " ++ x));
/*  prints:
      Item 0 is a
      Item 1 is b
      Item 2 is cc
    */
```

## forEachWithIndexU

```
let forEachWithIndexU: (t('a), [@bs] ((int, 'a) => 'b)) => unit;
```

Uncurried version of [forEachWithIndex](#forEachWithIndex).

## reduceU

```
let reduceU: (t('a), 'b, [@bs] (('b, 'a) => 'b)) => 'b;
```

## reduce

```
let reduce: (t('a), 'b, ('b, 'a) => 'b) => 'b;
```

## reduceWithIndexU

```
let reduceWithIndexU: (t('a), 'b, [@bs] (('b, 'a, int) => 'b)) => 'b;
```

## reduceWithIndex

```
let reduceWithIndex: (t('a), 'b, ('b, 'a, int) => 'b) => 'b;
```

## reduceReverseU

```
let reduceReverseU: (t('a), 'b, [@bs] (('b, 'a) => 'b)) => 'b;
```

## reduceReverse

```
let reduceReverse: (t('a), 'b, ('b, 'a) => 'b) => 'b;
```

## mapReverse2U

```
let mapReverse2U: (t('a), t('b), [@bs] (('a, 'b) => 'c)) => t('c);
```

## mapReverse2

```
let mapReverse2: (t('a), t('b), ('a, 'b) => 'c) => t('c);
```

## forEach2U

```
let forEach2U: (t('a), t('b), [@bs] (('a, 'b) => 'c)) => unit;
```

## forEach2

```
let forEach2: (t('a), t('b), ('a, 'b) => 'c) => unit;
```

## reduce2U

```
let reduce2U: (t('b), t('c), 'a, [@bs] (('a, 'b, 'c) => 'a)) => 'a;
```

## reduce2

```
let reduce2: (t('b), t('c), 'a, ('a, 'b, 'c) => 'a) => 'a;
```

## reduceReverse2U

```
let reduceReverse2U: (t('a), t('b), 'c, [@bs] (('c, 'a, 'b) => 'c)) => 'c;
```

## reduceReverse2

```
let reduceReverse2: (t('a), t('b), 'c, ('c, 'a, 'b) => 'c) => 'c;
```

## everyU

```
let everyU: (t('a), [@bs] ('a => bool)) => bool;
```

## every

```
let every: (t('a), 'a => bool) => bool;
```

## someU

```
let someU: (t('a), [@bs] ('a => bool)) => bool;
```

## some

```
let some: (t('a), 'a => bool) => bool;
```

## every2U

```
let every2U: (t('a), t('b), [@bs] (('a, 'b) => bool)) => bool;
```

## every2

```
let every2: (t('a), t('b), ('a, 'b) => bool) => bool;
```

## some2U

```
let some2U: (t('a), t('b), [@bs] (('a, 'b) => bool)) => bool;
```

## some2

```
let some2: (t('a), t('b), ('a, 'b) => bool) => bool;
```

## cmpByLength

```
let cmpByLength: (t('a), t('a)) => int;
```

## cmpU

```
let cmpU: (t('a), t('a), [@bs] (('a, 'a) => int)) => int;
```

## cmp

```
let cmp: (t('a), t('a), ('a, 'a) => int) => int;
```

## eqU

```
let eqU: (t('a), t('a), [@bs] (('a, 'a) => bool)) => bool;
```

## eq

```
let eq: (t('a), t('a), ('a, 'a) => bool) => bool;
```

## hasU

```
let hasU: (t('a), 'b, [@bs] (('a, 'b) => bool)) => bool;
```

## has

```
let has: (t('a), 'b, ('a, 'b) => bool) => bool;
```

## getByU

```
let getByU: (t('a), [@bs] ('a => bool)) => option('a);
```

## getBy

```
let getBy: (t('a), 'a => bool) => option('a);
```

## keepU

```
let keepU: (t('a), [@bs] ('a => bool)) => t('a);
```

## keep

```
let keep: (t('a), 'a => bool) => t('a);
```

## filter

```
let filter: (t('a), 'a => bool) => t('a);
```

## keepWithIndexU

```
let keepWithIndexU: (t('a), [@bs] (('a, int) => bool)) => t('a);
```

## keepWithIndex

```
let keepWithIndex: (t('a), ('a, int) => bool) => t('a);
```

## filterWithIndex

```
let filterWithIndex: (t('a), ('a, int) => bool) => t('a);
```

## keepMapU

```
let keepMapU: (t('a), [@bs] ('a => option('b))) => t('b);
```

## keepMap

```
let keepMap: (t('a), 'a => option('b)) => t('b);
```

## partitionU

```
let partitionU: (t('a), [@bs] ('a => bool)) => (t('a), t('a));
```

## partition

```
let partition: (t('a), 'a => bool) => (t('a), t('a));
```

## unzip

```
let unzip: t(('a, 'b)) => (t('a), t('b));
```

## getAssocU

```
let getAssocU: (t(('a, 'c)), 'b, [@bs] (('a, 'b) => bool)) => option('c);
```

## getAssoc

```
let getAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => option('c);
```

## hasAssocU

```
let hasAssocU: (t(('a, 'c)), 'b, [@bs] (('a, 'b) => bool)) => bool;
```

## hasAssoc

```
let hasAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => bool;
```

## removeAssocU

```
let removeAssocU: (t(('a, 'c)), 'b, [@bs] (('a, 'b) => bool)) => t(('a, 'c));
```

## removeAssoc

```
let removeAssoc: (t(('a, 'c)), 'b, ('a, 'b) => bool) => t(('a, 'c));
```

## setAssocU

```
let setAssocU: (t(('a, 'c)), 'a, 'c, [@bs] (('a, 'a) => bool)) => t(('a, 'c));
```

## setAssoc

```
let setAssoc: (t(('a, 'c)), 'a, 'c, ('a, 'a) => bool) => t(('a, 'c));
```

## sortU

```
let sortU: (t('a), [@bs] (('a, 'a) => int)) => t('a);
```

## sort

```
let sort: (t('a), ('a, 'a) => int) => t('a);
```
